# Chapter 1  变量和基本类型
[toc]

## **1.1 基本内置类型**

C++的基本数据类型包括**算数类型**和**空类型`void`**。其中：

- 算数类型包括**字符**，**整型数**，**布尔值**和**浮点数**。
- 空类型不对应具体的值，仅用作一些特殊的场合（例如函数的返回值）。

数据类型可以告诉我们**数据的意义以及我们能在数据上执行的操作**。

### 算数类型

#### 常见的算数类型

算数类型分为**整型**（包括字符、布尔类型）和**浮点型**。

|     类型      |      含义      |
| :-----------: | :------------: |
|    `bool`     |    布尔类型    |
|    `char`     |      字符      |
|    `short`    |     短整型     |
|     `int`     |      整型      |
|    `long`     |     长整型     |
|  `long long`  |     长整型     |
|    `float`    |  单精度浮点数  |
|   `double`    |  双精度浮点数  |
| `long double` | 扩展精度浮点数 |

> 对于他们的大小，C++语言有这样的规范：
>
> 一个`char`的空间应该确保可以存放机器基本字符集中的任意字符对应的数字值。也就是说，一个`char`的大小和一个机器字节一样。
>
> 一个`int`至少和一个`short`一样大，一个`long`至少和一个`int`一样大，一个`long long`至少和一个`long`一样大。

##### 符号类型和无符号类型

在上述提到的基本算珠类型中，除去布尔型，其他整型都可以划分为**带符号**和**无符号**两种类型。带符号类型使用`signed`表示，无符号类型使用`unsigned`表示。

| 有符号类型     | 无符号类型                    | 有符号类型          | 无符号类型           |
| -------------- | ----------------------------- | ------------------- | -------------------- |
| `(signed) int` | `unsigned int`/**`unsigned`** | `(signed)short`     | `unsigned short`     |
| `(signed)long` | `unsigned long`               | `(signed)long long` | `unsigned long long` |

> 字符整型被分为`signed char`和`unsigned char`三种类型。与其他类型不同，类型`char`和`signed char`并不相同。`char`类型是否带符号取决于不同的编译器。

#### 扩展的字符型

|    类型    |    含义     |                         说明                         |
| :--------: | :---------: | :--------------------------------------------------: |
| `wchar_t`  |   宽字符    | 用于确保可以存放机器最大扩展字符集中的任意一个字符。 |
| `char16_t` | Unicode字符 |                 用于Unicode字符集。                  |
| `char32_t` | Unicode字符 |                 用于Unicode字符集。                  |

#### 如何选用类型

> **如何选用类型:**
>
> - 如果数值不可能为负时，选用无符号类型。
> - 使用`int`执行整型运算，如果数值超出`int`表示范围，使用`long long`。
> - 只有表示字符时使用`char`，只有表示布尔值时使用`bool`。
> - 在使用字符型表示小整数时，注明`signed char`还是`unsigned char`。
> - 执行浮点数使用`double`。

### 如何使用代码查看各个基本类型的范围和大小

```cpp
#include <iostream>
#include <climits>	//<climits>库中储存了各个类型的范围
using namespace std;

int main() {
	//如何查看某个变量类型的大小
	cout << "int: " << sizeof(int) << " bits.\n";
	cout << "long: " << sizeof(long) << " bits.\n";
	cout << "long long: " << sizeof(long long) << " bits.\n";

	//使用<climits>查看变量范围
	cout << "int from " << INT_MIN << " to " << INT_MAX << ".\n";
	cout << "long from " << LONG_MIN << " to " << LONG_MAX << ".\n";
	cout << "char from " << CHAR_MIN << " to " << CHAR_MAX << ".\n";
	return 0;
}
```

## **1.2 类型转换**

### 将一种算术类型的值赋给另一种类型

- 将非布尔值赋给布尔类型，初始值为0，则结果为`false`，初始值不为0，则结果为`true`。
- 将布尔值赋给非布尔类型，初始值为`true`，则结果为1，初始值为`false`，则结果为0。
- 将浮点数赋给整数类型，进行了近似处理，结果值仅保留浮点数中小数点之前的部分。
- 将整数赋给浮点类型，小数部分记为0 。如果整数所占空间超过浮点类型容量，精度可能损失。

在赋值过程中，如果将超出某一类型范围的值赋给该类型变量时：

- 赋给无符号类型的结果是**对无符号类型表示的最大数值取模的余数**。
- 赋给有符号类型的结果是**未定义**的。**【避免无法预知和依赖于实现环境的行为】**

### 隐式类型转换

#### 何时会发生隐式类型转换

当两个运算对象类型不同时，C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则设法将运算对象的类型统一之后再求值。上述的类型转换是自动执行的，因此，它们被称为**隐式类型转换**。

隐式转换的设计原则是**尽可能避免损失精度**。

> 在下面的情况下，编译器会自动转换：
>
> - 在表达式中，比`int`类型小的整型值会首先提升为较大的整数类型。
> - 在条件中，非布尔值会转换为布尔值。
> - 初始化过程中，初始值转换为变量的类型。
> - 赋值语句中，右侧运算对象转换成左侧运算对象的类型。
> - 如果算术运算或关系运算的运算对象有多种类型，需要转换为一种类型。
> - 函数调用时发生的类型转换。

#### <span id="最主要的隐式转换：算数转换">最主要的隐式转换：算数转换</span>

算数转换是把一种算术类型转换为另一种算术类型。

##### <span id="整型提升">整型提升</span>

整型提升负责**将小整数类型转换为较大的整数类型**。

对于`bool`,`har`,`singed char`,`unsigned char`,`short`,`unsigned short`等类型来说，只要它们所有可能的值都能存在`int`类型中，它们就会提升为`int`类型，否则，提升为`unsigned int`类型。

> 在Visual Studio中，由于`int`类型占32字节，所以上述所有小整型都可以存在`int`类型中，所以在整型提升时均提升为`int`类型。

较大的字符型，比如`wchar_t`,`char16_t`,`char32_t`，会按照`int`,`unsigned int`,`long`,`unsigned long`,`long long `,`unsigned long long `的顺序依次检查，在能容纳所有可能的值的前提下选择最小的一种类型转换。

##### <span id="无符号类型的运算对象">无符号类型的运算对象</span>

如果运算对象一个是有符号的，一个是无符号的，则根据两个整数类型的相对大小进行转换（小类型向大类型转换）。

1. 如果无符号类型不小于有符号类型，则有符号的类型向无符号的类型转换。
2. 如果无符号类型小于有符号类型，则无符号的类型向有符号的类型转换。

> Visual Studio 上的转换：
>
> |             | `unsigned int`  | `unsigned long `                                             | `unsigned long long` |
> | ----------- | --------------- | ------------------------------------------------------------ | -------------------- |
> | `int`       | `unsigned int`  | `unsigned long`<br /><font face="Consola" size = 2 color=red> 和《C++Primer》有出入！</font> | `unsigned long long` |
> | `long`      | `unsigned long` | `unsigned long`                                              | `unsigned long long` |
> | `long long` | `long long`     | `long long`                                                  | `unsigned long long` |

#### <span id="算数转换的步骤">算数转换的步骤</span>

1. 首先对`char`,`bool`等小整型进行**整型提升**。
2. 如果整型提升之后类型不匹配：
   1. 如果运算对象中有浮点类型，则**所有运算对象转换为相应的浮点类型**。
   2. 如果没有浮点类型：
      1. 如果提升后的运算对象都是带符号的，或者都是不带符号的，则**小类型运算对象转换成较大的类型**。
      2. 如果提升后的运算对象既有有符号的，也有无符号的，则根据**无符号类型的运算对象**中的规则进行转换。

#### <span id="其他隐式转换">其他隐式转换</span>

- 数组转换为指针

- 指针的转换

  例如：常量整数值`0`和字面值`nullptr`可以转换成任意指针类型。指向非常量的指针能转换为`void*`，指向任意对象的指针能转换为`const void*`。

### <span id="显式类型转换（强制类型转换）">显式类型转换（强制类型转换）</span>

**字符和字符串字面值**

一个命名的强制类型转换具有如下形式：

```c++
cast-name <type> (expression)
```

其中:`type`是转换的目标类型。`expression`是要转换的值。
`cast-name`是`static_cast`,`dynamic_cast`,`const_cast`,`reinterpret_cast`中的一种。

**`static_cast`**

任何具有明确定义的类型转换，只要不包含底层`const`，都可以使用`static_cast`。

```c++
//利用static_cast执行强制执行浮点运算
int i =3, j = 2;
double slope = static_cast<double>(i) / j;
//将一个较大的算术类型赋值给较小的类型
int val = static_cast<int>(3.2);
//执行编译器无法自动执行的类型转换
double fval = 3.2;
void* p = &fval;
cout << *(static_cast<double*>(p));
```

**`const_cast`**

`const_cast`只能改变运算对象的底层`const`。因此**`const_cast`中的类型必须是指针、引用或指向对象类型成员的指针**。

将常量对象转换成非常量对象的行为一般称为“去掉`const`性质”。

只有`const_cast`能改变表达式的常量属性。其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同时，`const_cast`不能改变表达式的类型。

```c++
char ch = 'a', cch = '3';
const char* pch = &ch, * pcch = &cch;
char* p1 = const_cast<char*>(pch);    //正确。
char* p2 = const_cast<char*>(pcch);   //正确，但由于cch本身是一个常量，所以通过p2写值是未定义的行为。

const int val = 3;
const int& crval = val;
int& rval = static_cast<int&>(crval); //错误：static_cast无法丢掉常量或其他类型限定符

double fval = 3.2;
double* pfval = &fval;
int* pint = const_cast<int*>(fval);  //错误：const_cast 只能调节类型限定符；不能更改基础类型
```

**`reinterpret_cast`**

`reinterpret_cast`通常为运算对象的位模式提供较低层次上的重新解释。使用`reinterpret_cast`是十分危险的行为。

```c++
int* ip;
char* pc = reinterpret_cast<char*>(ip);
```

#### 旧式的强制类型转换

旧式的强制类型转换包含两种形式：

`type (expr)`和`(type) expr`

根据所涉及的类型不同，旧式的强制类型转换分别具有与`static_cast`,`const_cast`,`reinterpret_cast`相似的行为。

如果替换为`static_cast`或`const_cast`合法，则其行为与对应的命名转换一致。如果不合法，则执行与`reinterpret_cast`类似的功能。

## <span id="1.3字面值常量">**1.3 字面值常量**</span>

### <span id="整型字面值及类型">整型字面值及类型</span>

**整型字面值分为十进制数，八进制数或十六进制数**。

**以`0`开头的整数代表8进制数，以`0x`或`0X`开头的整数代表16进制数。**因此，为了表示十进制中的20，可以采用如下方法。

```c++
20/*dec*/    024/*oct*/    0x14/*hec*/
```

**注意：`-`不是字面值（例如`int x = -23;`），它的作用仅是对字面值取负。**

字面值类型是能容纳其数值的`int`,`unsigned int`,`long`,`unsigned long`,`long long`,`unsigned long long`中的最小的一个。<font face="Consola" size = 2 color=red> 和《C++Primer》有出入！</font>

> 在Visual Studio中，如果有：
>
> ```C++
> cout << -4294967290 << endl;
> ```
>
> 这样类似的写法，编译器会报错：error C4146: 一元负运算符应用于无符号类型，结果仍为无符号类型。
>
> 原因：当字面值为4294967290时，编译器发现`int`类型无法容纳，则决定使用`unsigned int`（实际上Visual Studio 使用`unsigned long`）容纳。因此出现了一元负运算符应用于无符号类型的错误。

### <span id="浮点型字面值及类型">浮点型字面值及类型</span>

**所有浮点型字面值的默认类型为`double`。**

**小数型字面值**

下面均是可行的形式：

```c++
3.14159   .1234/*0.1234*/    34./*34.0*/
```

**科学计数法**使用`E`或`e`表示指数部分。

下面均是可行的形式：

```C++
0.314159E1    3e1    0E0
```

### <span id="字符、字符串字面值及类型">字符、字符串字面值及类型</span>

**由单引号括起来的一个字符称为`char`型字面型。**

**由双引号括起来的零个或多个字符构成字符串型字面值。**

```C++
'a'    'b'    ' ' //char
"Hello World."      "" //字符串
```

**字符串字面值实际上是由常量字符构成的数组**（VS中为`const char[]`），编译器在每个字符串的结尾处添加一个空字符`'\0'`,因此，**字符串字面值的实际长度比它的内容多1**。

### <span id="布尔字面值和指针字面值">布尔字面值和指针字面值</span>

`true`和`false`是`bool`类型的字面值。

`nullptr`是指针字面值。[空指针](#空指针)

### <span id="转义序列">转义序列</span>

有些在C++语言中有特殊含义的字符（比如单引号、双引号）不能直接在字符（串）字面值中使用。在这些情况下需要使用**转义序列**。

常见的转义序列：

| 字符字面值不可使用 | 字符串字面值不可使用 |     有特殊含义      |   其他    |
| :----------------: | :------------------: | :-----------------: | :-------: |
|    `\\` 反斜线     |     `\\` 反斜线      |     `\n` 换行符     | `\?` 问号 |
|    `\'` 单引号     |      `\"`双引号      |     `\r` 回车符     |           |
|                    |                      |   `\t` 横向制表符   |           |
|                    |                      |     `\b` 退格符     |           |
|                    |                      | `\a` 报警（响铃）符 |           |

泛化的转义序列

泛化的转义字符的形式是`\x`后面跟着一位或多位十六进制字符，或者`\`后面跟着1位、2位或3位八进制数。

> 在Visual Studio中，十六进制数最多识别四位，八进制数最多识别三位，并且只要连续，会连续识别直到达到最大的位数。
>
> 如果十六进制数或八进制数太大，编译器会报错。
>
> <font face="Consola" size = 2 color=red> 和《C++Primer》有出入！</font>

### <span id="指定字面值的类型">指定字面值的类型</span>

| 前缀 | 含义            | 类型                                                  |
| ---- | --------------- | ----------------------------------------------------- |
| `u`  | Unicode 16 字符 | `char16_t`    (VS中的`cout << `转换为`int`)           |
| `U`  | Unicode 32 字符 | `char32_t`    (VS中的`cout << `转换为``unisgned int`) |
| `L`  | 宽字符          | `wchar_t`       (VS中的`cout << `转换为`int`)`        |
| `u8` | UTF-8           | `char`                                                |

**浮点型字面值**

| 后缀     | 类型     |
| -------- | -------- |
| `f`或`F` | `float`  |
| `l`或`L` | `double` |

**整型字面值**

| 后缀       | 最小匹配类型 |
| ---------- | ------------ |
| `u`或`U`   | `unsigned`   |
| `l`或`L`   | `long`       |
| `ll`或`LL` | `long long`  |

> 整型字面值后缀`u`可以和另外两个合在一起使用。比如：
>
> ```c++
> unsigned long long x = 12ULL, y = 12LLu;
> ```
>
> 如果字面值大于后缀最小匹配类型，C++会自动寻找更大的可以容纳的类型。

## <span id="1.4变量">**1.4 变量**</span>

### <span id="变量定义">变量定义</span>

变量定义的基本形式是：首先是**类型说明符**，随后紧跟有**一个或多个变量名组成的列表**，其中变量名以逗号分隔，最后以分号结束。列表中每个变量名的类型都**由类型说明符**指定。

### <span id="初始化">初始化</span>

#### <span id="初始化与赋值">初始化与赋值</span>

当对象在创建时获得了一个特定的值，我们说这个对象被**初始化**了，在同一条定义语句中，可以用先定义的变量值初始化后定义的其他变量。

在C++语言中，初始化和赋值是两个完全不同的操作。**初始化的含义是创建变量时赋予其一个初始值**，而**赋值的含义是把对象当前的值擦除，而以一个新的值来代替**。

#### <span id="初始化的形式">初始化的形式</span>

C++语言定义了初始化的好几种不同形式。以下四条语句均可以做到这一点：

```c++
	int x = 3;
	int y = { 3 };
	int z(0);
	int m{ 3 };
```

后文有关于这些初始化的详细描述。

##### <span id="列表初始化">列表初始化</span>

用花括号`{}`来初始化变量的形式被称为**列表初始化**。

使用内置类型的变量时，列表初始化有一个重要的特点：**如果初始值存在丢失信息的风险，则编译器将报错**。

#### <span id="默认初始化">默认初始化</span>

如果定义变量时没有指定初值，则变量被**默认初始化。**

**内置类型**

如果内置类型没有显式初始化，它的值由定义的为hi决定。**定义域任何函数体之外的变量被初始化为0**.**定义在函数体内部的内置类型变量将不被初始化**。试图访问此类值将会引发错误。

> error C4700: 使用了未初始化的局部变量。

**类**

每个类各自决定初始化对象的方式。

**`string`类**

`string`类规定如果没有指定初值则生成一个空串。

> 在Visual Studio中，没有显式构造函数的类在函数体内部定义但不初始化，试图访问此类值时不会编译报错，**但这些变量并没有被初始化为0**，在函数体外部定义则按照各自的类型默认初始化为0。
>
> `char[]`型字符串在函数体内部定义但不初始化，试图访问此类值时不会编译报错，但**每个字符也没有被初始化为0**。在函数体外部定义则初始化为0。

### <span id="变量声明与定义的关系（extern关键字）">变量声明与定义的关系（`extern`关键字）</span>

C++语言支持分离式编译机制，如果将程序分为多个文件，则需要有在文件间共享代码的方法。[11.2分离式编译](#11.2分离式编译)

为了支持分离式编译，C++语言将声明和定义区分开。**声明使得名字被程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义负责创建与名字关联的实体。**

如果想声明一个变量而非定义它，在变量名前加关键字`extern`，而不要显式地初始化变量。

```c++
extern int x;
```

任何在函数体外部包含显式初始化的声明即成为定义。在函数体内部如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

> error C2205: 不能对带有块范围的外部变量进行初始化。

变量在一个工程中只能被定义一次（函数体内部的局部变量除外），但是可以被多次声明。多次定义将出现链接错误。

> fatal error LNK1169: 找到一个或多个多重定义的符号。

### <span id="标识符">标识符</span>

C++的标识符由字母、数字和下划线组成。**必须以字母或下划线开头**。标识符对长度没有限制，但**对大小写敏感**。

C++语言保留了一些名字供语言本身使用（**C++关键字**和**C++操作符替代名**），这些名字不能被用作标识符。

[11.3C++操作符替代名](#11.3C++操作符替代名)

C++为标准库保留了一些名字,用户自定义的标识符不能连续出现两个下划线,也不能以下划线紧连大写字母开头．定义在函数体外的标识符不能以下划线开头。

> 在Visual Studio中没有出现编译错误或运行错误。

### <span id="变量命名规范">变量命名规范</span>

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如果由多个单词组成，则单词间应有明显区分。如`index`,`student_id`,`strdentLoan`。
- 用户自定义的类名一般以大写字母开头。

## <span id="1.5复合类型">**1.5 复合类型**</span>

###  <span id="引用">引用</span>

引用为对象另起了一个名字，引用类型引用另外一种类型。通过将**声明符**写成`&name`的形式来定义引用类型。

允许在一条语句中定义多个引用，其中**每个引用标识符都必须以符号`&`开头**。[理解复合类型的声明](#理解复合类型的声明)

绝大多数情况下，**引用的类型都需要和与之绑定的对象严格匹配**。例外：[const与引用](#const与引用)。

**引用只能绑定在对象上，而不能与某个字面值或某个表达式的计算结果绑定在一起。**

**定义引用时，程序把引用和它的初始值绑定在一起**。而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起引用指向的变量地址将不能再改变。**因为无法令引用重新绑定到另外一个对象，因此引用必须初始化**。

由于引用本身不是对象，所以不能定义引用的引用。

> **<font color = red> 区分引用初始化与赋值</font>**
>
> ```c++
> int x = 3, y = 4;
> int& p = x;
> cout << x << " " << y << " " << p << endl;
> cout << &x << " " << &y << " " << &p << endl;
> p = y;
> cout << x << " " << y << " " << p << endl;
> cout << &x << " " << &y << " " << &p << endl;
> ```
>
> `int &p = x`是引用的初始化，它的含义是将`p`与`x`绑定在一起，`p`相当于`x`的一个别名。
>
> `p = y`是将`y`的值赋给`p`指向的内存，也就是赋给变量`x`。
>
> 因此将代码运行，将得到：
>
> ```
> 3 4 3
> 003CFA24 003CFA18 003CFA24
> 4 4 4
> 003CFA24 003CFA18 003CFA24
> ```
>
> 即`p`指向的地址没有发生变化，但该地址的值发生变化。

### <span id="指针">指针</span>

#### <span id="指针的使用">指针的使用</span>

指针是指向另外一种类型的复合类型。指针和引用都实现了对对象的间接访问，然而指针与引用相比又有很多不同点。第一，指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。第二，指针无需再定义时初始化，和其他内置类型一样，在块作用域中定义的指针如果没有被初始化，将拥有一个不确定的值。

**绝大多数情况下，所有指针的类型都要和它所指向的对象严格匹配。**例外：[const和指针](#const和指针)

- 定义指针的方法是将声明符写成`*name`的形式，如果在一条语句中定义了几个指针变量，**每个变量前都需要有符号`*`**。[理解复合类型的声明](#理解复合类型的声明)
- 指针存放某个对象的地址，要想获取该地址，需要使用取地址符`&`。
- 如果指针指向了一个对象，则允许使用解引用符`*`来访问该对象。对对象解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上是给指针所指的对象赋值。

```c++
int val = 4;
int* pval = &val;
*pval = 5;
cout << val << " " << *pval << endl;
```

由于引用本身不是对象，其本身并没有对应的地址，对引用取地址将得到与其绑定的对象的地址，因此无法定义指向引用的指针。

#### <span id="空指针">空指针</span>

空指针不指向任何对象，下面语句都可以生成一个空指针。

```c++
int* p1 = NULL;
int* p2 = nullptr;
int* p3 = 0;
```

<span id="nullptr"> </span>`nullptr`是一种特殊类型的字面值，它可以被转换成任意其他类型的指针。[1.2类型转换](#1.2类型转换)

`NULL`是预处理变量，它的值就是0。但是不能将`int`变量直接赋给指针，即使`int`变量的值恰好为0。[11.5预处理器](#11.5预处理器)

#### <span id="关于指针的操作">关于指针的操作</span>

**条件表达式**

只要指针拥有一个合法值，就能将他用在条件表达式，转换原则和算数值作为条件的规则类似，即0-false， 1-true。[1.2类型转换](#1.2类型转换)

**比较**

对于两个类型相同的指针，可以用相等操作符`==`和不相等操作符`!=`来比较，如果两个指针存放的地址值相同，则它们相同，结果是`true`，如果不相同，结果为`false`。

#### <span id="void指针">`void*`指针</span>

`void*`指针是一种特殊的指针类型，可以存放任意对象的地址。

#### <span id="指向指针的指针">指向指针的指针</span>

通过`*`的个数可以区分指针的级别。`**`表示指向指针的指针，`***`表示指向 指向指针的指针 的指针。

```c++
int ival = 3;
int *pi = &ival;
int **ppi = &pi;
```

### <span id="理解复合类型的声明">理解复合类型的声明</span>

变量的定义包括一个**基本数据类型**和**一组声明符**。**在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式可以不同。因此一条定义语句可能定义出不同类型的变量。**

例如：

```c++
int i = 1024, *ptr = &i, &r = i;
//i是int型的变量，ptr是一个指针，r是一个int型引用。
```

#### <span id="指向指针的引用（两种修饰符混用）">指向指针的引用（两种修饰符混用）</span>

存在对指针的引用。

```c++
int ival = 1024; //int型变量
int kval = 2048; //int型变量
int* pi = &ival; //int型指针，指向ival
int*& r = pi;    //r引用了一个指针，因此r和pi是一个对象的两个不同的名字
r = &kval;       //给r赋值就是给pi赋值，因此pi是指向kval的指针
*r = 128;        //对r解引用就是对pi解引用。所以现在kval的值为128
```

面对一个比较复杂的指针或者引用的声明语句，从右向左阅读修饰符有助于理解真实含义。

> 在语句`int*& r = pi;`中，`r`的第一个修饰符是`&`，说明`r`是一个引用。之后是`*`说明引用的类型是一个指针。
>
> 类似的，可以定义指向指针的指针的引用。
>
> ```c++
> int x = 1;
> int* px = &x;
> int** ppx = &px;
> int**& r = ppx;
> ```

## <span id="1.6const限定符">**1.6 `const`限定符**</span>

### <span id="const常量">`const`常量</span>

如果我们希望定义这样一种变量，它的值不能被改变，可以使用关键字`const`对变量的类型加以限定。如：

```c++ 
const int bufSize = 512;
```

因为`const`常量一旦创建后其值就不能再改变，因此**`const`变量必须初始化**。

与非`const`相比，`const`类型的对象能完成其中大部分操作（如对另一个对象赋值，输出对象的值），除了改变其内容的操作（如赋值）。任何试图改变其内容的操作都将引发错误。

### <span id="const对象的有效范围">`const`对象的有效范围</span>

当以编译时初始化的方式定义一个`const`对象时，编译器再编译过程中会把用到该变量的地方都替换成对应的值。为了执行上述操作，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须能访问到它的初始值。这使得每个文件都要有对该对象的定义。参考变量声明与定义的关系。因此，默认情况下，**`const`对象被设定为仅在当前文件内有效（即使它们都具有全局作用域）**。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)

如果一个`const`对象需要在多个文件中使用，需要添加`extern`关键字。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)通常的做法是：**对于`const`变量，不管是声明还是定义，都添加`extern`关键字，这样只需要定义一次就可以了。**

### <span id="const与引用">`const`与引用</span>

形如`const int r = &x;`形式的引用被称为**对`const`的引用**，也称为**常量引用**。

将（对`const`的）引用绑定在被`const`限定符限定的对象上被称为**对常量的引用**。

**只有对`const`的引用可以引用`const`常量；对`const`的引用则可能引用一个并非`const`的对象。**

> ```c++
> const int cival = 12;
> int& r1 = &cival;		//错误
> const int& r2 = cival;	//正确
> int ival = 123;
> const int& r3 = ival;	//正确
> ```
>
> 对常量的引用必须使用对`const`的引用，使用一般的引用不合法。（如果合法，则可以通过引用改变常量的值，这违背了常量不可被改变的性质）。
>
> 对`const`的引用可以引用常量，也可以引用变量。不同的是，**如果使用将对`const`的引用绑定到变量上，则不能通过引用改变变量的值，变量的值仍可以通过其他的途径更改**（如对被绑定的对象直接赋值）。

#### <span id="常量引用的初始化">常量引用的初始化</span>

在初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。[1.2类型转换](#1.2类型转换)。因此，**允许为一个常量引用绑定字面值，甚至是一个一般表达式。**例如:

```c++
const int &r2 = 3;
const int &r3 = 3.12 * 3;
const int &r4 = min('a', '5');
```

在这种情况下，**这些引用绑定了一个临时量**。所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

> 运行代码:
>
> ```c++
> double x = 3.2;
> const int& r = x;
> const double& rx = x;
> cout << x << " " << r << " " << rx << endl;
> cout << &x << " " << &r << " " << &rx << endl;
> ```
>
> 得到：
>
> ```
> 3.2 3 3.2
> 0076FD18 0076FD00 0076FD18
> ```
>
> 当引用的类型和其所引用的对象类型不一致时，引用实际指向的是临时量所在的内存。
>
> 因此，`cosnt int& r = x;`实际上和如下的代码是等价的：
>
> ```c++
> const int temp = x;
> const int& r = temp;
> ```

### <span id="const和指针">`const`和指针</span>

- 形如`const int* ptr = &val;`形式的指针被称作**指向常量的指针(pointer to const)**。
- 形如`int *const curErr = &errNumb`形式的指针被称为**常量指针(const pointer)**。

和引用类似：**指向常量的指针(pointer to const)可以指向常量，也可以指向变量，但常量只能由指向常量的指针(pointer to const)指向。并且指向变量的指向常量的指针(pointer to const)不能修改变量的值，但仍可以通过其他途径修改。**

**指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指的是不是一个常量就是两个相互独立的问题。**用名词**顶层`const`**来表示指针本身是个常量，用名词**底层`const`**来表示指针所指的对象是一个常量。[顶层const与底层const](#顶层const与底层const)

> **<font color = red> 区别指向常量的指针(pointer to const)和常量指针(const pointer)</font>**
>
> 指向常量的指针(pointer to const)的一般格式是`const type-name * name`，是指这个指针指向的对象是一个`const`常量，但是指针（作为一个对象）本身不是常量，它还可以通过赋值等操作指向其他对象。
>
> 常量指针(const pointer)的一般格式是`type-name *const name`，它指向`type-name`对应的对象（不一定是常量），这个指针（作为一个对象）本身是一个常量，即，不能再改变该指针指向的对象（指针指向的地址）。
>
> 弄清楚的最好办法是从右向左读。例如：
>
> ```c++
> const double pi = 3.14159;
> const double * ptr_pi = &pi;
> const double * *const cp = &ptr_pi;
> ```
>
> `const double* *const`首先是`const`，即cp本身是一个常量，之后是`*`，说明cp是一个常量指针，他指向`const double *`类型的对象，就是`ptr_pi`。对于`const double * ptr_pi`，从右向左第一个是`*`，即`ptr_pi`是一个指针，它指向`const double`类型的对象，即`pi`。因此`ptr_pi`是一个指向常量的指针。

### <span id="顶层const与底层const">顶层`const`与底层`const`</span>

一般的：

**顶层`const`可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针。**

**底层`const`则指指针和引用等复合类型的基本类型是`const`常量。**

- 算数类型、类等是顶层`const`。
- 引用是底层`const`（由于引用一旦初始化就不能再次更改绑定的对象，因此所有引用都有`const`的性质，因此`const`修饰符特指底层`const`）。
- 指针既可以是顶层`cosnt`，也可以是底层`const`。
- 虽然算数类型、类等是顶层`cosnt`,但是对它们取地址和引用是底层`const`。对指针来说，取地址之后，原本的算术类型、类等的`const`对地址来说是底层的。地址本身并不是`const`。对引用来说，被绑定的对象是`const`的。

```C++
int i = 3;						
const int ci = 42;			//顶层const
const int &r = ci;			//所有用于声明引用的const都是底层const
int *const p1 = &i;			//顶层const
const int *p2 = &ci;		//底层const
const int *const p3 = &ci;	//左边的const是底层const，右边的是顶层const
```

#### <span id="拷贝操作与const">拷贝操作与`const`</span>

当执行（指针）对象的拷贝操作时，顶层和底层`const`区别明显。

**顶层`const`：**

执行拷贝操作并不会改变被拷贝对象的值，因此拷出的对象是否是常量都没什么影响，但是由于顶层`const`本身不能被修改，所以拷入的对象不能是顶层`const`。

```c++
int val = 3;
const int cval = 4;
int *ptr = &val;					//顶层const
const int* ptrToC = &cval;			//底层const
int *const cPtr = &val;				//顶层const
const int *const cPtrToC = &cval;	//顶层const，底层const
ptrToC = cPtrToC;	//正确
cPtrToC = ptrToC;	//错误
ptr = cPtr;			//正确
cPtr = ptr;			//错误
```

**底层`const`：**

当执行拷贝操作时，拷入拷出的对象必须具有相同的底层`const`资格，或者拷出对象的数据类型可以转换为拷入对象的数据类型（即非`const`可以向`const`转换，而`const`不可以向非`const`转换。

```c++
int val = 3;
const int cval = 4;
int* ptr = &val;					 
const int* ptrToC = &cval;		
int* const cPtr = &val;			
const int* const cPtrToC = &cval;
ptrToC = cPtrToC;		//正确
ptrToC = cPtr;			//正确：非const向const转换
ptr = cPtrToC;			//错误：const不能向非const转换
```

> 能不能相互拷贝遵循的原则是：**原来可以改变的（非`const`）可以变为不可以改变的（`const`），但原本不可以改变的不可以变为可以改变的。**

### <span id="constexpr和常量表达式">`constexpr`和常量表达式</span>

#### <span id="常量表达式">常量表达式</span>

常量表达式是指**值不会改变**，并且**在编译过程中就能得到计算结果**的表达式。

例如：

```c++
const int max_files = 20;			//是常量表达式
const int limit = max_files + 20;	//是常量表达式
int staff_size = 27;				//不是常量表达式
const int sz = get_size();			//不是常量表达式
```

尽管`staff_size`的初始值是一个字面值常量，但是由于它是普通的`int`类型，所以它的值可能会发生改变。

虽然`sz`是一个常量，但是`get_size()`的值只有在运行之后才能得到结果，所以也不是一个常量表达式。

#### <span id="constexpr变量">`constexpr`变量</span>

在一个复杂系统中，很难分辨一个初始值是不是常量表达式。因此允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是不是一个常量表达式。

声明为`constexpr`的变量一定是一个常量，并且必须用常量表达式初始化，因此不能使用变量或普通的函数作为`constexpr`变量的初始值。

> 在Visual Studio中运行代码：
>
> ```c++
> int get_size() {
> 	const int x = 4;
> 	return x;
> }
> //···
> 	int number = 4;
> 	constexpr int x = number;
> 	constexpr int t = get_size();
> ```
>
> 得到的错误信息为：
>
> ```
> error C2131: 表达式的计算结果不是常数
> message : 因读取超过生命周期的变量而失败
> message : 请参见“number”的用法
> error C2131: 表达式的计算结果不是常数
> message : 对未定义的函数或为未声明为“constexpr”的函数的调用导致了故障
> message : 请参见“get_size”的用法
> ```

#### <span id="字面值类型">字面值类型</span>

常量表达式的值需要在编译时就得到计算，因此声明`constexpr`时用到的类型必须有所限制。**这些可用的类型被称为字面值类型**。

**算术类型、指针、引用都属于字面值类型**。自定义类、IO库、`string`类型不属于字面值类型。 

**指针和引用都能定义为`constexpr`**，但他们的初始值受到严格限制。**一个`constexpr`指针的初始值必须是`nullptr`或`0`，或者是存储于某个固定地址中的对象。**

函数体内部定义的变量一般来说并非放在固定的地址中，所以`constexpr`指针不能指向这样的对象。**定义于函数体之外的对象和函数定义的有效范围超出函数本身的变量**有固定的地址，所以`constexpr`指针可以指向这样的对象，`constexpr`也可以绑定到这样的变量上。

##### <span id="指针和constexpr">指针和`constexpr`</span>

如果在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效（即把它所定义的指针置为了顶层`const`），与其他常量指针一样，`constexpr`指针既可以指向常量也可以指向变量。[顶层const与底层const](#顶层const与底层const)

## <span id="1.7处理类型">**1.7 处理类型**</span>

### <span id="类型别名">类型别名</span>

类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，有助于程序员清楚地知道使用该类型的真实目的。

#### <span id="使用typedef关键字定义类型别名">使用`typedef`关键字定义类型别名</span>

```c++
typedef double lfloat;			//lfoat和double等价
typedef lfloat base, *p;		//base和lfoat,double等价，p和*lfoat,*double等价，是指向double的指针
typedef int arrT[10];			//arrT是int[10]的类型别名
```

关键字`typedef`作为声明语句的基本数据类型的一部分出现。含有`typedef`的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。[理解复合类型的声明](#理解复合类型的声明)。理解某个类型别名真正含义的办法同样是从右向左读。

#### <span id="使用别名声明定义类型别名">使用别名声明定义类型别名</span>

```c++
using LF = double;
using Cint = const int;
using arr = int[10];
using refer = int&;
```

#### <span id="指针、常量和类型别名">指针、常量和类型别名</span>

> **<font color = red> 正确理解类型别名声明语句</font>**
>
> [顶层const与底层const](#顶层const与底层const)
> [const和指针](#const和指针)
>
> ```c++
> typedef char *pstring;
> const pstring cstr = 0;
> const pstring *ps;
> ```
>
> 上述两条声明语句的基本数据类型都是`const pstring`。`const`是对给定类型的修饰，`pstring`是指向`char`的指针，因此`const pstring`是指向`char`的常量指针，属于顶层`const`。
> 因此`cstr`是指向`char`的常量指针，`ps`是指向常量指针的指针。
>
> ```c++
> typedef char *pstring;
> const pstring cstr = 0;
> const char *cstr = 0;
> ```
>
> **在理解类型别名时，不能直接将类型别名替换成他本来的名字。**
>
> <font color=red>上述第二行和第三行并不等价。</font> `const char*`从右向左第一个修饰符是`*`，说明此时`cstr`是一个指针，它指向的类型是`const char`是一个常量。因此此时，`cstr`是一个指向常量的指针，属于底层`cosnt`。

### <span id="auto类型说明符">`auto`类型说明符</span>

`auto`说明符能让编译器分析表达式所属的类型。`auto`定义的变量必须有初始值。

```c++
auto x = 3.14;   //auto和double等价
```

使用`auto`**可以在一条语句中声明多个变量**，因为一条声明语句只能有一个基本数据类型，[理解复合类型的声明](#理解复合类型的声明)，所以该语句中所有变量的初始基本数据类型必须一致。

```c++ 
auto i = 0, *p = &i;        //正确
auto size = 0, pi = 3.14;   //不正确
```

#### <span id="复合类型、常量和auto">复合类型、常量和`auto`</span>

[const与引用](#const与引用)
[const和指针](#const和指针)
[顶层const与底层const](#顶层const与底层const)

编译器推断出来的`auto`类型有时候和初始值不完全一样，编译器会适当地改变结果使其更符合初始化规则。

- **当引用被用作`auto`的初始值时，编译器以引用对象的类型作为`auto`的类型。**
- **`auto`一般会忽略顶层`const`，而保留底层`const`**。

```c++
int val = 3;
const int cval = 34;
const int* const pcval = &cval;
auto x = cval;  	//auto = int，忽略cval的顶层const性质
auto ptr = pcval; 	//auto = const int*，保留pcval的底层const 忽略顶层const
auto p = &cval; 	//auto = const int*，对常量取地址是底层const
```

- **如果希望推断出的类型是顶层`const`，需要明确指出。**

```c++
const auto cptr = pcval; //cptr的类型是const int * const
```

- **可以将引用的类型设置为`auto`，引用的初始化在这里仍然适用。[常量引用的初始化](#常量引用的初始化)
- **设置一个类型为`auto`的引用时，初始值中的顶层`const`仍然保留。[顶层const与底层const](#顶层const与底层const)
- **符号`*`,`&`属于某个声明符，而非基本数据类型的一部分。因此初始值必须是同一种类型。（`const int`和`int`是不同的类型）。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)**

```c++
int val;
const int cval = 4;
auto &r1 = val, &r2 = cval;  //错误，val和cval属于不同的类型。
auto &r3 = val, *p = &val;   //正确，它们都是int类型,只是两个声明符中的修饰符不同。
```

### <span id="decltype类型指示符">`decltype`类型指示符</span>

类型说明符`decltype`的作用是选择并返回操作数的数据类类型。操作数可以是对象，也可以是表达式、函数。在此过程中，编译器只分析操作数并得到它的类型（表达式的类型，函数的返回类型，对象的类型），但是不计算表达式的值。

```c++
const int cval = 0, &r = cval;
decltype(cval) x = 0;    //const int
decltype(r) y = x;		 //const int&
decltype(r) z = 12;		 //const int&
decltype(3.5 + 'a') w = 3.42; //double
```

和`auto`不同的是，`decltype`会完全保留（复制）表达式的类型，如果表达式是引用，结果就是引用；并且不会丢弃顶层`const`。

```c++
const int val = 32;
const int &rval = val;
const int* const ptr = &val;
decltype(ptr) w = nullptr;		//const int* const
decltype(rval) ref = val;      //const int&
```

**使用关键词`decltype`的时候，左值和右值有所不同**

如果表达式的求值结果是左值，`decltype`作用域该表达式（不是变量）得到一个引用类型。

> 假定`p`的类型是`int*`，因为解引用生成左值，所以`decltype(*p)`得到的结果是`int&`。
>
> 假定`p`的类型是`int*`，因为取地址生成右值，所以`decltype(&p)`得到的结果是`int**`。

**如果`decltype`作用于一个变量**

如果变量名加上了一对括号，则得到的类型与不加括号会有所不同。如果作用于不加括号的变量，得到的结果就是该变量的类型。如果给变量加上一层或多层括号，编译器就会当成一个表达式，变量是一种可以作为赋值语句左值的特殊表达式，因此这时候`decltype`会得到引用类型。

```C++
int i = 3;
decltype(i) x = 3;		//int
decltype((i)) y = i;	//int&
```

## <span id="自定义数据结构">自定义数据结构</span>

[八、类](