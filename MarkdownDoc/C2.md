# Chapter 2 复合类型

[toc]

**复合类型**是指基于其他类型定义的类型。C++语言有多种复合类型，其中最基础的时引用和指针。

在变量声明部分，我们指出，变量定义的基本形式是：**基本数据类型 + 声明符列表**，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

对于基本类型，其声明符即为其标识符（名字）。然而，对于复合类型，其说明符会变得复杂。

## **2.1 对象的地址**

计算机以比特序列存储数据。可寻址的最小内存块称为**字节`byte`**，存储的基本单元称为**字`word`**，它通常由几个字节组成。

大多数计算机将内存中的每个字节与一个（通常为16进制的）数字关联起来。**与内存中每个字节相关联的数字被称为地址（address）**。我们能够使用某个地址来表示从这个地址开始的大小不同的比特串（比如`int`类型是4个字节，`long long`是8个字节）。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。**类型决定了数据所占的比特数以及该如何解释这些比特的内容**。

### 获取对象的地址

为了获得某个对象在计算机中所在的地址，需要使用**取地址符`&`**。结合`sizeof`运算符可以得到某个对象在计算机中存储的位置。

```cpp
#include <iostream>
using namespace std;

int main() {
	long long lval = 0;
	int val = 0;
	long long* ladr = &lval;
	int* adr = &val;
	cout << "lval : from " << ladr << " to " << (ladr + int(sizeof(lval))) << endl;
	cout << "val : from " << adr << " to " << (adr + int(sizeof(val))) << endl;
}
```



## **2.2 引用**

<font color = blue>【引用与const的结合，参考常量部分】</font>

**引用**(reference)为对象起了另外一个名字，引用类型引用另外一种类型。

**通过将声明符写成`&val`的形式来定义引用类型。其中`val`是变量的标识符。**

```cpp
int ival = 1;
int &refIval = ival;
```

### 引用即别名

**引用并非对象**，相反，他只是为一个已经存在的对象另外起一个名字。

在定义引用时，程序把引用和它的初始值**绑定**在一起，一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此**引用必须初始化**。

从地址的角度来说，对对象本身和它的引用取地址，得到的地址是相同的。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

由于引用本身不是一个对象，因此**不能定义引用的引用**。

```cpp
#include <iostream>
using namespace std;

int main() {
	int ival = 0;
	int& refIval = ival;
//	int& refIval2;	//Error: 引用必须初始化
	ival = 2;
	cout << "ival = " << ival << ", refIval = " << refIval << endl;
	refIval += 2;
	cout << "ival = " << ival << ", refIval = " << refIval << endl;
	cout << "Address of ival: " << &ival
		<< ", address of refIval: " << &refIval << endl;
}
```

### 绑定还是赋值？

如果写出如下的代码

```cpp
int ival = 0, ival1 = 2;
int& refIval = ival;
refIval = ival1;
```

看起来我们更改了`refIval`的绑定对象，将其绑定到了`ival1`对象上。但是，如果执行如下的代码

```cpp
#include <iostream>
using namespace std;

int main() {
	int ival = 0, ival1 = 2;
	int& refIval = ival;
	refIval = ival1;
	cout << "ival = " << ival << endl
		<< "refIval = " << refIval << endl;
	cout << "address of ival is " << &ival << endl
		<< "address of refIval is " << &refIval << endl
		<< "address of ival1 is " << &ival1 << endl;
}
```

会发现`ival`的值变为2，并且`refIval`的地址与`ival`相同而不是`ival1`。

在这里，编译器将`refIval = ival1;`看作是赋值语句而不是绑定语句。因此，其和`ival = ival1`是等价的。因此，执行该条代码的效果是将`ival1`的值赋给了`ival`。

## **2.3 指针**

<font color = blue>【指针与const的结合，参考常量部分】</font>

定义指针的方法是将声明符写成`*d`的形式。**指针存放某个对象的地址**，其实现了对某个对象的间接访问。

除了某些特殊情况，**指针的类型需要和他所指的对象严格匹配**。

如果指针指向了一个对象，则可以使用**解引用符`*`**来访问该对象。

和引用不同的是，指针属于对象，因此可以定义指针的指针，也可以定义指针的引用。

```cpp
#include <iostream>
using namespace std;

int main() {
	int val = 0;
	int* pVal = &val;
//	double* pDVal = &val; //Error.
	cout << *pVal << endl;
	*pVal += 3;
	cout << val << endl;
}

```

### 空指针

**空指针不指向任何一个对象**。以下是几个生成空指针的方法：

```cpp
#include <iostream>
using namespace std;

int main() {
	int* ptr1 = nullptr;
	int* ptr2 = NULL;
	int* ptr3 = 0;
}
```

### `void*`指针

**`void*`指针是一种特殊的指针类型，可用于存放任意对象的地址。**我们仅能够将此类指针和其他指针比较，作为函数的输入和输出，或者赋给另一个`void*`指针（而不能赋给其他类型的指针），而不能直接操作指针所指向的对象。

> 简单来说，`void*`指针仅保存了某一个地址。由于我们不知道该地址存储着什么类型的值，所以我们无法访问内存空间中所存的对象。

**由于`void*`指针可以存放任意对象的地址，因此任意对象的地址都可以使用`static_cast`转换为`void*`指针。此外，由于`void*`可以存放任意对象的地址，因此使用`static_cast`可以将`void*`转换为任意类型对象的指针**。

### 基于指针的操作

#### 条件值

只要指针拥有一个合法值，就能将它用在条件表达式中。和采用算数值作为条件遵循的规则类似，如果指针的值为0，条件取`false`，任何非0指针对应的条件值都是`true`。

#### 相等与比较

对于**两个类型相同且均合法**的指针，可以用相等操作符`==`和不等操作符`!=`来比较他们。如果两个指针的地址相同，则它们相等，反之不相等。

**对于两个指针，如果某个指针指向的位置在另一个指针所指向的位置之后，则说第一个指针大于`>`后一个指针。反之则小于。**

#### 递增、与整数的运算

C++支持指针加上或减去一个整数，其效果是将指针指向的位置相前或向后移动指定的偏移量。

**对于指针来说，指针移动的最小偏移量是其所指的类型的大小**。由于`void*`不指向某种特定的类型，因此`void*`指针不支持算术运算。

此外，指针还可以使用递增运算符`++`和递减运算符`--`。

```cpp
#include <iostream>
using namespace std;

int main() {
	int arr[] = { 0, 1, 2, 3, 4, 5, 6 };
	int* ptr = &(arr[3]);
	cout << *(++ptr) << endl;
	ptr += 2;
	cout << *(ptr - 2) << endl;
}

```

#### 两指针的运算

可以令两个指针相减，其结果是两者的距离。也就是说

```cpp
if
	int delta = ptr1 - ptr2
then
	ptr1 = ptr2 + delta
```

### 使用指针的危险性

**<font color = red>错误地使用指针会导致无法预计的后果</font>**

指针的值应该属于下列4种状态之一：

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置（一般用于迭代器）
- 空指针
- 无效指针

其中，<font color=red>试图访问无效指针的值将引发无法预计的后果</font>，因此，程序员必须清楚任意给定的指针是否是有效的。除此之外，第二种和第三种形式的指针尽管是有效的，但是他们的使用受到很大的限制。<font color=red>对该类指针使用解引用符也会引发无法预计的后果</font>。

**<font color = red>使用未经初始化的指针是引发运行时错误的一大原因</font>**

和其他变量一样，未经初始化的指针的值时未定义的，但是和基本类型不同的是，<font color = red>编译器不负责检查未初始化指针造成的错误</font>。因此，在使用过程中，应在定义了对象之后再定义指向它的指针，并且保证**初始化所有指针**，包括还不清楚应该指向何处的（初始化为空指针）。

**在可能的情况下， 避免使用指针**

## **2.4 复杂复合类型的声明**

如前所述，变量的定义包含一个基本数据类型和一组声明符。在同一条定义语句中，虽然基本数据类型只能有一个，但是声明符的形式却可以不同。如

```cpp
int val = 3, * ptr = &val, & ref = val;
//ptr是指向val的指针，ref是val的引用。
```

并且，**在定义语句中，类型修饰符仅作用于紧随它的一个变量**，如

```cpp
int val = 3;
int* ptr = &val, val2 = 3;//ptr是指针，而val2是int型变量。
```

由于指针可以嵌套使用，因此复合类型的声明可能会非常复杂。例如

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
	int val = 1;
	int* pVal = &val;		//pVal是指向val的指针
	int** ppVal = &pVal;		//ppVal是指向pVal的指针
	int**& rppVal = ppVal;		//rppVal是ppVal的引用
}

```

面对一条比较复杂的指针或引用的声明语句时，**从右向左阅读有利于理解其真实含义**。除此之外，也可以使用`auto`和`typedef`简化理解复杂声明语句。

## **2.5 常量**

### `const`对象

常量是其值不能被改变的变量。我们可以**使用关键字`const`对变量的类型加以限定，定义常量**。

由于`const`对象一旦定义后其值不可以再改变，**因此`const`常量必须初始化**，并且任何试图改变常量值的操作都会引发错误。

#### `const`对象仅在文件内有效

当编译`const`对象时，编译器将在编译过程中把用到该变量的地方都替换为对应的值。为了执行上述替换，编译器必须知道常量的初始值。如果程序包含多个文件，则在每一个用到变量的文件中都有它的定义。为了支持这一做法，并且避免对同一变量的重复定义，默认情况下， **`const`对象被设置为仅在当前文件有效**，也就是说，当多个文件中出现了同名的`const`变量时，等同于在不同文件中分别定义了独立的变量。

**如果想在多个文件之间共享`const`对象，必须在变量的定义之前添加`extern`关键字**。

### `const`与复合类型

#### 常量引用

可以把引用绑定到`const`对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用**。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。

```cpp
int main() {
	const double PI = 3.14;
	const double& ref = PI;
//	ref = 3.15; //Error 不能修改常量值
}
```

#### 指向常量的指针&指针常量

和引用不同，指针和指针指向的位置都是对象。**指向常量的指针**是指指针中储存的地址可以改变，但是指针指向的那片内存对应的是常量类型。而**指针常量**是指指针本身是一个常量，即存储地址的那片内存不可修改，然而该地址所指向的对象不一定是常量。

和复杂声明类似，区分两者的方法是从右向左阅读。如

```cpp
int main() {
	int val = 0;
	const int cVal = 3;
	int* const CptrToVal = &val;	//指向int的常量指针
	const int* ptrToCval = &cVal;	//指向const int的指针
	const int* const CptrToCval = &cVal;	//指向const int的常量指针
}

```



