# Chapter 2 复合类型

[toc]

**复合类型**是指基于其他类型定义的类型。C++语言有多种复合类型，其中最基础的时引用和指针。

在变量声明部分，我们指出，变量定义的基本形式是：**基本数据类型 + 声明符列表**，其中声明符以逗号分隔，最后以分号结束。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

对于基本类型，其声明符即为其标识符（名字）。然而，对于复合类型，其说明符会变得复杂。

## **2.1 对象的地址**

计算机以比特序列存储数据。可寻址的最小内存块称为**字节`byte`**，存储的基本单元称为**字`word`**，它通常由几个字节组成。

大多数计算机将内存中的每个字节与一个（通常为16进制的）数字关联起来。**与内存中每个字节相关联的数字被称为地址（address）**。我们能够使用某个地址来表示从这个地址开始的大小不同的比特串（比如`int`类型是4个字节，`long long`是8个字节）。为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据的类型。**类型决定了数据所占的比特数以及该如何解释这些比特的内容**。

### 获取对象的地址

为了获得某个对象在计算机中所在的地址，需要使用**取地址符`&`**。结合`sizeof`运算符可以得到某个对象在计算机中存储的位置。

```cpp
#include <iostream>
using namespace std;

int main() {
	long long lval = 0;
	int val = 0;
	long long* ladr = &lval;
	int* adr = &val;
	cout << "lval : from " << ladr << " to " << (ladr + int(sizeof(lval))) << endl;
	cout << "val : from " << adr << " to " << (adr + int(sizeof(val))) << endl;
}
```



## **2.2 引用**

**引用**(reference)为对象起了另外一个名字，引用类型引用另外一种类型。

**通过将声明符写成`&val`的形式来定义引用类型。其中`val`是生命的变量名。**

```cpp
int ival = 1;
int &refIval = ival;
```

### 引用即别名

**引用并非对象**，相反，他只是为一个已经存在的对象另外起一个名字。

在定义引用时，程序把引用和它的初始值**绑定**在一起，一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此**引用必须初始化**。

从地址的角度来说，对对象本身和它的引用取地址，得到的地址是相同的。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

由于引用本身不是一个对象，因此**不能定义引用的引用**。

```cpp
#include <iostream>
using namespace std;

int main() {
	int ival = 0;
	int& refIval = ival;
//	int& refIval2;	//Error: 引用必须初始化
	ival = 2;
	cout << "ival = " << ival << ", refIval = " << refIval << endl;
	refIval += 2;
	cout << "ival = " << ival << ", refIval = " << refIval << endl;
	cout << "Address of ival: " << &ival
		<< ", address of refIval: " << &refIval << endl;
}
```

### 绑定还是赋值？

如果写出如下的代码

```cpp
int ival = 0, ival1 = 2;
int& refIval = ival;
refIval = ival1;
```

看起来我们更改了`refIval`的绑定对象，将其绑定到了`ival1`对象上。但是，如果执行如下的代码

```cpp
#include <iostream>
using namespace std;

int main() {
	int ival = 0, ival1 = 2;
	int& refIval = ival;
	refIval = ival1;
	cout << "ival = " << ival << endl
		<< "refIval = " << refIval << endl;
	cout << "address of ival is " << &ival << endl
		<< "address of refIval is " << &refIval << endl
		<< "address of ival1 is " << &ival1 << endl;
}
```

会发现`ival`的值变为2，并且`refIval`的地址与`ival`相同而不是`ival1`。

在这里，编译器将`refIval = ival1;`看作是赋值语句而不是绑定语句。因此，其和`ival = ival1`是等价的。因此，执行该条代码的效果是将`ival1`的值赋给了`ival`。