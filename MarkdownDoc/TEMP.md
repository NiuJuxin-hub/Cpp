# **1.4 变量**

### <span id="变量定义">变量定义</span>

变量定义的基本形式是：首先是**类型说明符**，随后紧跟有**一个或多个变量名组成的列表**，其中变量名以逗号分隔，最后以分号结束。列表中每个变量名的类型都**由类型说明符**指定。

### <span id="初始化">初始化</span>

#### <span id="初始化与赋值">初始化与赋值</span>

当对象在创建时获得了一个特定的值，我们说这个对象被**初始化**了，在同一条定义语句中，可以用先定义的变量值初始化后定义的其他变量。

在C++语言中，初始化和赋值是两个完全不同的操作。**初始化的含义是创建变量时赋予其一个初始值**，而**赋值的含义是把对象当前的值擦除，而以一个新的值来代替**。

#### <span id="初始化的形式">初始化的形式</span>

C++语言定义了初始化的好几种不同形式。以下四条语句均可以做到这一点：

```c++
	int x = 3;
	int y = { 3 };
	int z(0);
	int m{ 3 };
```

后文有关于这些初始化的详细描述。

##### <span id="列表初始化">列表初始化</span>

用花括号`{}`来初始化变量的形式被称为**列表初始化**。

使用内置类型的变量时，列表初始化有一个重要的特点：**如果初始值存在丢失信息的风险，则编译器将报错**。

#### <span id="默认初始化">默认初始化</span>

如果定义变量时没有指定初值，则变量被**默认初始化。**

**内置类型**

如果内置类型没有显式初始化，它的值由定义的为hi决定。**定义域任何函数体之外的变量被初始化为0**.**定义在函数体内部的内置类型变量将不被初始化**。试图访问此类值将会引发错误。

> error C4700: 使用了未初始化的局部变量。

**类**

每个类各自决定初始化对象的方式。

**`string`类**

`string`类规定如果没有指定初值则生成一个空串。

> 在Visual Studio中，没有显式构造函数的类在函数体内部定义但不初始化，试图访问此类值时不会编译报错，**但这些变量并没有被初始化为0**，在函数体外部定义则按照各自的类型默认初始化为0。
>
> `char[]`型字符串在函数体内部定义但不初始化，试图访问此类值时不会编译报错，但**每个字符也没有被初始化为0**。在函数体外部定义则初始化为0。

### <span id="变量声明与定义的关系（extern关键字）">变量声明与定义的关系（`extern`关键字）</span>

C++语言支持分离式编译机制，如果将程序分为多个文件，则需要有在文件间共享代码的方法。[11.2分离式编译](#11.2分离式编译)

为了支持分离式编译，C++语言将声明和定义区分开。**声明使得名字被程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。定义负责创建与名字关联的实体。**

如果想声明一个变量而非定义它，在变量名前加关键字`extern`，而不要显式地初始化变量。

```c++
extern int x;
```

任何在函数体外部包含显式初始化的声明即成为定义。在函数体内部如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

> error C2205: 不能对带有块范围的外部变量进行初始化。

变量在一个工程中只能被定义一次（函数体内部的局部变量除外），但是可以被多次声明。多次定义将出现链接错误。

> fatal error LNK1169: 找到一个或多个多重定义的符号。

### <span id="标识符">标识符</span>

C++的标识符由字母、数字和下划线组成。**必须以字母或下划线开头**。标识符对长度没有限制，但**对大小写敏感**。

C++语言保留了一些名字供语言本身使用（**C++关键字**和**C++操作符替代名**），这些名字不能被用作标识符。

[11.3C++操作符替代名](#11.3C++操作符替代名)

C++为标准库保留了一些名字,用户自定义的标识符不能连续出现两个下划线,也不能以下划线紧连大写字母开头．定义在函数体外的标识符不能以下划线开头。

> 在Visual Studio中没有出现编译错误或运行错误。

### <span id="变量命名规范">变量命名规范</span>

- 标识符要能体现实际含义。
- 变量名一般用小写字母，如果由多个单词组成，则单词间应有明显区分。如`index`,`student_id`,`strdentLoan`。
- 用户自定义的类名一般以大写字母开头。

## <span id="1.5复合类型">**1.5 复合类型**</span>

###  <span id="引用">引用</span>

引用为对象另起了一个名字，引用类型引用另外一种类型。通过将**声明符**写成`&name`的形式来定义引用类型。

允许在一条语句中定义多个引用，其中**每个引用标识符都必须以符号`&`开头**。[理解复合类型的声明](#理解复合类型的声明)

绝大多数情况下，**引用的类型都需要和与之绑定的对象严格匹配**。例外：[const与引用](#const与引用)。

**引用只能绑定在对象上，而不能与某个字面值或某个表达式的计算结果绑定在一起。**

**定义引用时，程序把引用和它的初始值绑定在一起**。而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起引用指向的变量地址将不能再改变。**因为无法令引用重新绑定到另外一个对象，因此引用必须初始化**。

由于引用本身不是对象，所以不能定义引用的引用。

> **<font color = red> 区分引用初始化与赋值</font>**
>
> ```c++
> int x = 3, y = 4;
> int& p = x;
> cout << x << " " << y << " " << p << endl;
> cout << &x << " " << &y << " " << &p << endl;
> p = y;
> cout << x << " " << y << " " << p << endl;
> cout << &x << " " << &y << " " << &p << endl;
> ```
>
> `int &p = x`是引用的初始化，它的含义是将`p`与`x`绑定在一起，`p`相当于`x`的一个别名。
>
> `p = y`是将`y`的值赋给`p`指向的内存，也就是赋给变量`x`。
>
> 因此将代码运行，将得到：
>
> ```
> 3 4 3
> 003CFA24 003CFA18 003CFA24
> 4 4 4
> 003CFA24 003CFA18 003CFA24
> ```
>
> 即`p`指向的地址没有发生变化，但该地址的值发生变化。

### <span id="指针">指针</span>

#### <span id="指针的使用">指针的使用</span>

指针是指向另外一种类型的复合类型。指针和引用都实现了对对象的间接访问，然而指针与引用相比又有很多不同点。第一，指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。第二，指针无需再定义时初始化，和其他内置类型一样，在块作用域中定义的指针如果没有被初始化，将拥有一个不确定的值。

**绝大多数情况下，所有指针的类型都要和它所指向的对象严格匹配。**例外：[const和指针](#const和指针)

- 定义指针的方法是将声明符写成`*name`的形式，如果在一条语句中定义了几个指针变量，**每个变量前都需要有符号`*`**。[理解复合类型的声明](#理解复合类型的声明)
- 指针存放某个对象的地址，要想获取该地址，需要使用取地址符`&`。
- 如果指针指向了一个对象，则允许使用解引用符`*`来访问该对象。对对象解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上是给指针所指的对象赋值。

```c++
int val = 4;
int* pval = &val;
*pval = 5;
cout << val << " " << *pval << endl;
```

由于引用本身不是对象，其本身并没有对应的地址，对引用取地址将得到与其绑定的对象的地址，因此无法定义指向引用的指针。

#### <span id="空指针">空指针</span>

空指针不指向任何对象，下面语句都可以生成一个空指针。

```c++
int* p1 = NULL;
int* p2 = nullptr;
int* p3 = 0;
```

<span id="nullptr"> </span>`nullptr`是一种特殊类型的字面值，它可以被转换成任意其他类型的指针。[1.2类型转换](#1.2类型转换)

`NULL`是预处理变量，它的值就是0。但是不能将`int`变量直接赋给指针，即使`int`变量的值恰好为0。[11.5预处理器](#11.5预处理器)

#### <span id="关于指针的操作">关于指针的操作</span>

**条件表达式**

只要指针拥有一个合法值，就能将他用在条件表达式，转换原则和算数值作为条件的规则类似，即0-false， 1-true。[1.2类型转换](#1.2类型转换)

**比较**

对于两个类型相同的指针，可以用相等操作符`==`和不相等操作符`!=`来比较，如果两个指针存放的地址值相同，则它们相同，结果是`true`，如果不相同，结果为`false`。

#### <span id="void指针">`void*`指针</span>

`void*`指针是一种特殊的指针类型，可以存放任意对象的地址。

#### <span id="指向指针的指针">指向指针的指针</span>

通过`*`的个数可以区分指针的级别。`**`表示指向指针的指针，`***`表示指向 指向指针的指针 的指针。

```c++
int ival = 3;
int *pi = &ival;
int **ppi = &pi;
```

### <span id="理解复合类型的声明">理解复合类型的声明</span>

变量的定义包括一个**基本数据类型**和**一组声明符**。**在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式可以不同。因此一条定义语句可能定义出不同类型的变量。**

例如：

```c++
int i = 1024, *ptr = &i, &r = i;
//i是int型的变量，ptr是一个指针，r是一个int型引用。
```

#### <span id="指向指针的引用（两种修饰符混用）">指向指针的引用（两种修饰符混用）</span>

存在对指针的引用。

```c++
int ival = 1024; //int型变量
int kval = 2048; //int型变量
int* pi = &ival; //int型指针，指向ival
int*& r = pi;    //r引用了一个指针，因此r和pi是一个对象的两个不同的名字
r = &kval;       //给r赋值就是给pi赋值，因此pi是指向kval的指针
*r = 128;        //对r解引用就是对pi解引用。所以现在kval的值为128
```

面对一个比较复杂的指针或者引用的声明语句，从右向左阅读修饰符有助于理解真实含义。

> 在语句`int*& r = pi;`中，`r`的第一个修饰符是`&`，说明`r`是一个引用。之后是`*`说明引用的类型是一个指针。
>
> 类似的，可以定义指向指针的指针的引用。
>
> ```c++
> int x = 1;
> int* px = &x;
> int** ppx = &px;
> int**& r = ppx;
> ```

## <span id="1.6const限定符">**1.6 `const`限定符**</span>

### <span id="const常量">`const`常量</span>

如果我们希望定义这样一种变量，它的值不能被改变，可以使用关键字`const`对变量的类型加以限定。如：

```c++ 
const int bufSize = 512;
```

因为`const`常量一旦创建后其值就不能再改变，因此**`const`变量必须初始化**。

与非`const`相比，`const`类型的对象能完成其中大部分操作（如对另一个对象赋值，输出对象的值），除了改变其内容的操作（如赋值）。任何试图改变其内容的操作都将引发错误。

### <span id="const对象的有效范围">`const`对象的有效范围</span>

当以编译时初始化的方式定义一个`const`对象时，编译器再编译过程中会把用到该变量的地方都替换成对应的值。为了执行上述操作，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了`const`对象的文件都必须能访问到它的初始值。这使得每个文件都要有对该对象的定义。参考变量声明与定义的关系。因此，默认情况下，**`const`对象被设定为仅在当前文件内有效（即使它们都具有全局作用域）**。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)

如果一个`const`对象需要在多个文件中使用，需要添加`extern`关键字。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)通常的做法是：**对于`const`变量，不管是声明还是定义，都添加`extern`关键字，这样只需要定义一次就可以了。**

### <span id="const与引用">`const`与引用</span>

形如`const int r = &x;`形式的引用被称为**对`const`的引用**，也称为**常量引用**。

将（对`const`的）引用绑定在被`const`限定符限定的对象上被称为**对常量的引用**。

**只有对`const`的引用可以引用`const`常量；对`const`的引用则可能引用一个并非`const`的对象。**

> ```c++
> const int cival = 12;
> int& r1 = &cival;		//错误
> const int& r2 = cival;	//正确
> int ival = 123;
> const int& r3 = ival;	//正确
> ```
>
> 对常量的引用必须使用对`const`的引用，使用一般的引用不合法。（如果合法，则可以通过引用改变常量的值，这违背了常量不可被改变的性质）。
>
> 对`const`的引用可以引用常量，也可以引用变量。不同的是，**如果使用将对`const`的引用绑定到变量上，则不能通过引用改变变量的值，变量的值仍可以通过其他的途径更改**（如对被绑定的对象直接赋值）。

#### <span id="常量引用的初始化">常量引用的初始化</span>

在初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。[1.2类型转换](#1.2类型转换)。因此，**允许为一个常量引用绑定字面值，甚至是一个一般表达式。**例如:

```c++
const int &r2 = 3;
const int &r3 = 3.12 * 3;
const int &r4 = min('a', '5');
```

在这种情况下，**这些引用绑定了一个临时量**。所谓临时量就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

> 运行代码:
>
> ```c++
> double x = 3.2;
> const int& r = x;
> const double& rx = x;
> cout << x << " " << r << " " << rx << endl;
> cout << &x << " " << &r << " " << &rx << endl;
> ```
>
> 得到：
>
> ```
> 3.2 3 3.2
> 0076FD18 0076FD00 0076FD18
> ```
>
> 当引用的类型和其所引用的对象类型不一致时，引用实际指向的是临时量所在的内存。
>
> 因此，`cosnt int& r = x;`实际上和如下的代码是等价的：
>
> ```c++
> const int temp = x;
> const int& r = temp;
> ```

### <span id="const和指针">`const`和指针</span>

- 形如`const int* ptr = &val;`形式的指针被称作**指向常量的指针(pointer to const)**。
- 形如`int *const curErr = &errNumb`形式的指针被称为**常量指针(const pointer)**。

和引用类似：**指向常量的指针(pointer to const)可以指向常量，也可以指向变量，但常量只能由指向常量的指针(pointer to const)指向。并且指向变量的指向常量的指针(pointer to const)不能修改变量的值，但仍可以通过其他途径修改。**

**指针本身是一个对象，它又可以指向另一个对象。因此，指针本身是不是常量和指针所指的是不是一个常量就是两个相互独立的问题。**用名词**顶层`const`**来表示指针本身是个常量，用名词**底层`const`**来表示指针所指的对象是一个常量。[顶层const与底层const](#顶层const与底层const)

> **<font color = red> 区别指向常量的指针(pointer to const)和常量指针(const pointer)</font>**
>
> 指向常量的指针(pointer to const)的一般格式是`const type-name * name`，是指这个指针指向的对象是一个`const`常量，但是指针（作为一个对象）本身不是常量，它还可以通过赋值等操作指向其他对象。
>
> 常量指针(const pointer)的一般格式是`type-name *const name`，它指向`type-name`对应的对象（不一定是常量），这个指针（作为一个对象）本身是一个常量，即，不能再改变该指针指向的对象（指针指向的地址）。
>
> 弄清楚的最好办法是从右向左读。例如：
>
> ```c++
> const double pi = 3.14159;
> const double * ptr_pi = &pi;
> const double * *const cp = &ptr_pi;
> ```
>
> `const double* *const`首先是`const`，即cp本身是一个常量，之后是`*`，说明cp是一个常量指针，他指向`const double *`类型的对象，就是`ptr_pi`。对于`const double * ptr_pi`，从右向左第一个是`*`，即`ptr_pi`是一个指针，它指向`const double`类型的对象，即`pi`。因此`ptr_pi`是一个指向常量的指针。

### <span id="顶层const与底层const">顶层`const`与底层`const`</span>

一般的：

**顶层`const`可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针。**

**底层`const`则指指针和引用等复合类型的基本类型是`const`常量。**

- 算数类型、类等是顶层`const`。
- 引用是底层`const`（由于引用一旦初始化就不能再次更改绑定的对象，因此所有引用都有`const`的性质，因此`const`修饰符特指底层`const`）。
- 指针既可以是顶层`cosnt`，也可以是底层`const`。
- 虽然算数类型、类等是顶层`cosnt`,但是对它们取地址和引用是底层`const`。对指针来说，取地址之后，原本的算术类型、类等的`const`对地址来说是底层的。地址本身并不是`const`。对引用来说，被绑定的对象是`const`的。

```C++
int i = 3;						
const int ci = 42;			//顶层const
const int &r = ci;			//所有用于声明引用的const都是底层const
int *const p1 = &i;			//顶层const
const int *p2 = &ci;		//底层const
const int *const p3 = &ci;	//左边的const是底层const，右边的是顶层const
```

#### <span id="拷贝操作与const">拷贝操作与`const`</span>

当执行（指针）对象的拷贝操作时，顶层和底层`const`区别明显。

**顶层`const`：**

执行拷贝操作并不会改变被拷贝对象的值，因此拷出的对象是否是常量都没什么影响，但是由于顶层`const`本身不能被修改，所以拷入的对象不能是顶层`const`。

```c++
int val = 3;
const int cval = 4;
int *ptr = &val;					//顶层const
const int* ptrToC = &cval;			//底层const
int *const cPtr = &val;				//顶层const
const int *const cPtrToC = &cval;	//顶层const，底层const
ptrToC = cPtrToC;	//正确
cPtrToC = ptrToC;	//错误
ptr = cPtr;			//正确
cPtr = ptr;			//错误
```

**底层`const`：**

当执行拷贝操作时，拷入拷出的对象必须具有相同的底层`const`资格，或者拷出对象的数据类型可以转换为拷入对象的数据类型（即非`const`可以向`const`转换，而`const`不可以向非`const`转换。

```c++
int val = 3;
const int cval = 4;
int* ptr = &val;					 
const int* ptrToC = &cval;		
int* const cPtr = &val;			
const int* const cPtrToC = &cval;
ptrToC = cPtrToC;		//正确
ptrToC = cPtr;			//正确：非const向const转换
ptr = cPtrToC;			//错误：const不能向非const转换
```

> 能不能相互拷贝遵循的原则是：**原来可以改变的（非`const`）可以变为不可以改变的（`const`），但原本不可以改变的不可以变为可以改变的。**

### <span id="constexpr和常量表达式">`constexpr`和常量表达式</span>

#### <span id="常量表达式">常量表达式</span>

常量表达式是指**值不会改变**，并且**在编译过程中就能得到计算结果**的表达式。

例如：

```c++
const int max_files = 20;			//是常量表达式
const int limit = max_files + 20;	//是常量表达式
int staff_size = 27;				//不是常量表达式
const int sz = get_size();			//不是常量表达式
```

尽管`staff_size`的初始值是一个字面值常量，但是由于它是普通的`int`类型，所以它的值可能会发生改变。

虽然`sz`是一个常量，但是`get_size()`的值只有在运行之后才能得到结果，所以也不是一个常量表达式。

#### <span id="constexpr变量">`constexpr`变量</span>

在一个复杂系统中，很难分辨一个初始值是不是常量表达式。因此允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是不是一个常量表达式。

声明为`constexpr`的变量一定是一个常量，并且必须用常量表达式初始化，因此不能使用变量或普通的函数作为`constexpr`变量的初始值。

> 在Visual Studio中运行代码：
>
> ```c++
> int get_size() {
> 	const int x = 4;
> 	return x;
> }
> //···
> 	int number = 4;
> 	constexpr int x = number;
> 	constexpr int t = get_size();
> ```
>
> 得到的错误信息为：
>
> ```
> error C2131: 表达式的计算结果不是常数
> message : 因读取超过生命周期的变量而失败
> message : 请参见“number”的用法
> error C2131: 表达式的计算结果不是常数
> message : 对未定义的函数或为未声明为“constexpr”的函数的调用导致了故障
> message : 请参见“get_size”的用法
> ```

#### <span id="字面值类型">字面值类型</span>

常量表达式的值需要在编译时就得到计算，因此声明`constexpr`时用到的类型必须有所限制。**这些可用的类型被称为字面值类型**。

**算术类型、指针、引用都属于字面值类型**。自定义类、IO库、`string`类型不属于字面值类型。 

**指针和引用都能定义为`constexpr`**，但他们的初始值受到严格限制。**一个`constexpr`指针的初始值必须是`nullptr`或`0`，或者是存储于某个固定地址中的对象。**

函数体内部定义的变量一般来说并非放在固定的地址中，所以`constexpr`指针不能指向这样的对象。**定义于函数体之外的对象和函数定义的有效范围超出函数本身的变量**有固定的地址，所以`constexpr`指针可以指向这样的对象，`constexpr`也可以绑定到这样的变量上。

##### <span id="指针和constexpr">指针和`constexpr`</span>

如果在`constexpr`声明中定义了一个指针，限定符`constexpr`仅对指针有效（即把它所定义的指针置为了顶层`const`），与其他常量指针一样，`constexpr`指针既可以指向常量也可以指向变量。[顶层const与底层const](#顶层const与底层const)

## <span id="1.7处理类型">**1.7 处理类型**</span>

### <span id="类型别名">类型别名</span>

类型别名是一个名字，它是某种类型的同义词。使用类型别名有很多好处，它让复杂的类型名字变得简单明了、易于理解和使用，有助于程序员清楚地知道使用该类型的真实目的。

#### <span id="使用typedef关键字定义类型别名">使用`typedef`关键字定义类型别名</span>

```c++
typedef double lfloat;			//lfoat和double等价
typedef lfloat base, *p;		//base和lfoat,double等价，p和*lfoat,*double等价，是指向double的指针
typedef int arrT[10];			//arrT是int[10]的类型别名
```

关键字`typedef`作为声明语句的基本数据类型的一部分出现。含有`typedef`的声明语句定义的不再是变量而是类型别名。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。[理解复合类型的声明](#理解复合类型的声明)。理解某个类型别名真正含义的办法同样是从右向左读。

#### <span id="使用别名声明定义类型别名">使用别名声明定义类型别名</span>

```c++
using LF = double;
using Cint = const int;
using arr = int[10];
using refer = int&;
```

#### <span id="指针、常量和类型别名">指针、常量和类型别名</span>

> **<font color = red> 正确理解类型别名声明语句</font>**
>
> [顶层const与底层const](#顶层const与底层const)
> [const和指针](#const和指针)
>
> ```c++
> typedef char *pstring;
> const pstring cstr = 0;
> const pstring *ps;
> ```
>
> 上述两条声明语句的基本数据类型都是`const pstring`。`const`是对给定类型的修饰，`pstring`是指向`char`的指针，因此`const pstring`是指向`char`的常量指针，属于顶层`const`。
> 因此`cstr`是指向`char`的常量指针，`ps`是指向常量指针的指针。
>
> ```c++
> typedef char *pstring;
> const pstring cstr = 0;
> const char *cstr = 0;
> ```
>
> **在理解类型别名时，不能直接将类型别名替换成他本来的名字。**
>
> <font color=red>上述第二行和第三行并不等价。</font> `const char*`从右向左第一个修饰符是`*`，说明此时`cstr`是一个指针，它指向的类型是`const char`是一个常量。因此此时，`cstr`是一个指向常量的指针，属于底层`cosnt`。

### <span id="auto类型说明符">`auto`类型说明符</span>

`auto`说明符能让编译器分析表达式所属的类型。`auto`定义的变量必须有初始值。

```c++
auto x = 3.14;   //auto和double等价
```

使用`auto`**可以在一条语句中声明多个变量**，因为一条声明语句只能有一个基本数据类型，[理解复合类型的声明](#理解复合类型的声明)，所以该语句中所有变量的初始基本数据类型必须一致。

```c++ 
auto i = 0, *p = &i;        //正确
auto size = 0, pi = 3.14;   //不正确
```

#### <span id="复合类型、常量和auto">复合类型、常量和`auto`</span>

[const与引用](#const与引用)
[const和指针](#const和指针)
[顶层const与底层const](#顶层const与底层const)

编译器推断出来的`auto`类型有时候和初始值不完全一样，编译器会适当地改变结果使其更符合初始化规则。

- **当引用被用作`auto`的初始值时，编译器以引用对象的类型作为`auto`的类型。**
- **`auto`一般会忽略顶层`const`，而保留底层`const`**。

```c++
int val = 3;
const int cval = 34;
const int* const pcval = &cval;
auto x = cval;  	//auto = int，忽略cval的顶层const性质
auto ptr = pcval; 	//auto = const int*，保留pcval的底层const 忽略顶层const
auto p = &cval; 	//auto = const int*，对常量取地址是底层const
```

- **如果希望推断出的类型是顶层`const`，需要明确指出。**

```c++
const auto cptr = pcval; //cptr的类型是const int * const
```

- **可以将引用的类型设置为`auto`，引用的初始化在这里仍然适用。[常量引用的初始化](#常量引用的初始化)
- **设置一个类型为`auto`的引用时，初始值中的顶层`const`仍然保留。[顶层const与底层const](#顶层const与底层const)
- **符号`*`,`&`属于某个声明符，而非基本数据类型的一部分。因此初始值必须是同一种类型。（`const int`和`int`是不同的类型）。[变量声明与定义的关系（extern关键字）](#变量声明与定义的关系（extern关键字）)**

```c++
int val;
const int cval = 4;
auto &r1 = val, &r2 = cval;  //错误，val和cval属于不同的类型。
auto &r3 = val, *p = &val;   //正确，它们都是int类型,只是两个声明符中的修饰符不同。
```

### <span id="decltype类型指示符">`decltype`类型指示符</span>

类型说明符`decltype`的作用是选择并返回操作数的数据类类型。操作数可以是对象，也可以是表达式、函数。在此过程中，编译器只分析操作数并得到它的类型（表达式的类型，函数的返回类型，对象的类型），但是不计算表达式的值。

```c++
const int cval = 0, &r = cval;
decltype(cval) x = 0;    //const int
decltype(r) y = x;		 //const int&
decltype(r) z = 12;		 //const int&
decltype(3.5 + 'a') w = 3.42; //double
```

和`auto`不同的是，`decltype`会完全保留（复制）表达式的类型，如果表达式是引用，结果就是引用；并且不会丢弃顶层`const`。

```c++
const int val = 32;
const int &rval = val;
const int* const ptr = &val;
decltype(ptr) w = nullptr;		//const int* const
decltype(rval) ref = val;      //const int&
```

**使用关键词`decltype`的时候，左值和右值有所不同**

如果表达式的求值结果是左值，`decltype`作用域该表达式（不是变量）得到一个引用类型。

> 假定`p`的类型是`int*`，因为解引用生成左值，所以`decltype(*p)`得到的结果是`int&`。
>
> 假定`p`的类型是`int*`，因为取地址生成右值，所以`decltype(&p)`得到的结果是`int**`。

**如果`decltype`作用于一个变量**

如果变量名加上了一对括号，则得到的类型与不加括号会有所不同。如果作用于不加括号的变量，得到的结果就是该变量的类型。如果给变量加上一层或多层括号，编译器就会当成一个表达式，变量是一种可以作为赋值语句左值的特殊表达式，因此这时候`decltype`会得到引用类型。

```C++
int i = 3;
decltype(i) x = 3;		//int
decltype((i)) y = i;	//int&
```

## <span id="自定义数据结构">自定义数据结构</span>

[八、类](